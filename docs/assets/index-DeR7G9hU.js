var it=Object.defineProperty;var st=(o,t,e)=>t in o?it(o,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):o[t]=e;var M=(o,t,e)=>st(o,typeof t!="symbol"?t+"":t,e);(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const i of document.querySelectorAll('link[rel="modulepreload"]'))n(i);new MutationObserver(i=>{for(const r of i)if(r.type==="childList")for(const c of r.addedNodes)c.tagName==="LINK"&&c.rel==="modulepreload"&&n(c)}).observe(document,{childList:!0,subtree:!0});function e(i){const r={};return i.integrity&&(r.integrity=i.integrity),i.referrerPolicy&&(r.referrerPolicy=i.referrerPolicy),i.crossOrigin==="use-credentials"?r.credentials="include":i.crossOrigin==="anonymous"?r.credentials="omit":r.credentials="same-origin",r}function n(i){if(i.ep)return;i.ep=!0;const r=e(i);fetch(i.href,r)}})();const ct="modulepreload",at=function(o,t){return new URL(o,t).href},G={},lt=function(t,e,n){let i=Promise.resolve();if(e&&e.length>0){const c=document.getElementsByTagName("link"),s=document.querySelector("meta[property=csp-nonce]"),a=(s==null?void 0:s.nonce)||(s==null?void 0:s.getAttribute("nonce"));i=Promise.allSettled(e.map(f=>{if(f=at(f,n),f in G)return;G[f]=!0;const l=f.endsWith(".css"),d=l?'[rel="stylesheet"]':"";if(!!n)for(let w=c.length-1;w>=0;w--){const p=c[w];if(p.href===f&&(!l||p.rel==="stylesheet"))return}else if(document.querySelector(`link[href="${f}"]${d}`))return;const h=document.createElement("link");if(h.rel=l?"stylesheet":ct,l||(h.as="script"),h.crossOrigin="",h.href=f,a&&h.setAttribute("nonce",a),document.head.appendChild(h),l)return new Promise((w,p)=>{h.addEventListener("load",w),h.addEventListener("error",()=>p(new Error(`Unable to preload CSS for ${f}`)))})}))}function r(c){const s=new Event("vite:preloadError",{cancelable:!0});if(s.payload=c,window.dispatchEvent(s),!s.defaultPrevented)throw c}return i.then(c=>{for(const s of c||[])s.status==="rejected"&&r(s.reason);return t().catch(r)})};var y=(o=>(o.EUCLIDEAN="EUCLIDEAN",o.COSINE="COSINE",o.MAXIMUM_INNER_PRODUCT="MAXIMUM_INNER_PRODUCT",o))(y||{});const ut=4,ht=1,L=1/15,dt=.1,ft=5,mt=[[-.798,.798],[-1.493,1.493],[-2.051,2.051],[-2.514,2.514],[-2.916,2.916],[-3.278,3.278],[-3.611,3.611],[-3.922,3.922]],Q={CONVERGENCE_THRESHOLD:1e-8,MIN_DETERMINANT:1e-12,EPSILON:1e-8},pt=new Uint8Array(256);for(let o=0;o<256;o++){let t=0,e=o;for(;e>0;)t+=e&1,e>>>=1;pt[o]=t}function wt(o){let t=0;for(let e=0;e<o.length;e++){const n=o[e];n!==void 0&&(t+=n*n)}return Math.sqrt(t)}function gt(o){let t=0;for(let e=0;e<o.length;e++){const n=o[e];n!==void 0&&(t+=n)}return t/o.length}function Et(o,t){let e=0;for(let n=0;n<o.length;n++){const i=o[n];if(i!==void 0){const r=i-t;e+=r*r}}return Math.sqrt(e/o.length)}function k(o,t,e){return Math.min(Math.max(o,t),e)}function vt(o,t=Q.CONVERGENCE_THRESHOLD){return Math.abs(o)<t}function Y(o,t,e=Q.EPSILON){return Math.abs(o-t)<e}const A=class A{constructor(t){M(this,"lambda");M(this,"iters");M(this,"similarityFunction");this.lambda=t.lambda??dt,this.iters=t.iters??ft,this.similarityFunction=t.similarityFunction??y.EUCLIDEAN}multiScalarQuantize(t,e,n,i){if(e.length!==n.length)throw new Error("目标数组和位数数组长度不匹配");const r=[];for(let c=0;c<e.length;c++){const s=e[c],a=n[c];if(s&&a!==void 0){const f=this.scalarQuantize(t,s,a,i);r.push(f)}}return r}scalarQuantize(t,e,n,i){const r=new Float32Array(t);if(!t)throw new Error("输入向量不能为空");if(!e)throw new Error("目标数组不能为空");if(!i)throw new Error("质心向量不能为空");if(t.length!==i.length)throw new Error("向量和质心维度不匹配");if(e.length!==t.length)throw new Error("目标数组长度与向量长度不匹配");if(n<1||n>8)throw new Error("位数必须在1-8之间");for(let m=0;m<t.length;m++){const v=t[m];if(v!==void 0){if(isNaN(v))throw new Error(`向量位置 ${m} 包含NaN值`);if(!isFinite(v))throw new Error(`向量位置 ${m} 包含Infinity值`)}}let c=0;if(this.similarityFunction!==y.EUCLIDEAN)for(let m=0;m<t.length;m++){const v=t[m],S=i[m];v!==void 0&&S!==void 0&&(c+=v*S)}let s=Number.MAX_VALUE,a=-Number.MAX_VALUE;for(let m=0;m<t.length;m++){const v=t[m],S=i[m];if(v!==void 0&&S!==void 0){const C=v-S;r[m]=C,s=Math.min(s,C),a=Math.max(a,C)}}const f=gt(r),l=Et(r,f),d=wt(r),u=this.getInitialInterval(n,l,f,s,a);this.optimizeIntervals(u,r,d,1<<n);const[h,w]=u,E=(1<<n)-1,g=E>0?(w-h)/E:0,z=g>0?1/g:0;let I=0;for(let m=0;m<r.length;m++){const v=r[m],S=k(v,h,w);if(n===1){const C=(h+w)/2,D=S>=C?1:0;e[m]=D,I+=D}else{const C=Math.round((S-h)*z);e[m]=Math.min(C,E),I+=C}}const N=this.similarityFunction===y.EUCLIDEAN?d:c;return{lowerInterval:u[0],upperInterval:u[1],additionalCorrection:N,quantizedComponentSum:I}}getInitialInterval(t,e,n,i,r){const c=mt[t-1];if(!c)throw new Error(`未找到位数 ${t} 对应的网格配置`);const s=c[0],a=c[1];if(s===void 0||a===void 0)throw new Error(`网格配置不完整: ${c}`);return[k(s*e+n,i,r),k(a*e+n,i,r)]}optimizeIntervals(t,e,n,i){let r=this.computeLoss(e,t,i,n);const c=this.lambda,s=this.iters,a=(1-c)/n;if(isFinite(a))for(let f=0;f<s;f++){const[l,d]=t,u=(i-1)/(d-l);let h=0,w=0,p=0,E=0,g=0;for(let D=0;D<e.length;D++){const U=e[D];if(U!==void 0){const q=k(U,l,d),b=Math.round((q-l)*u)/(i-1);h+=(1-b)*(1-b),w+=(1-b)*b,p+=b*b,E+=U*(1-b),g+=U*b}}const z=a*E*E+c*h,I=a*E*g+c*w,N=a*g*g+c*p,m=z*N-I*I;if(vt(m,Q.MIN_DETERMINANT))return;const v=(N*E-I*g)/m,S=(z*g-I*E)/m;if(Y(t[0],v)&&Y(t[1],S))return;const C=this.computeLoss(e,[v,S],i,n);if(C>r)return;t[0]=v,t[1]=S,r=C}}computeLoss(t,e,n,i){const[r,c]=e,s=(c-r)/(n-1),a=1/s,f=this.lambda;let l=0,d=0;for(let u=0;u<t.length;u++){const h=t[u];if(h!==void 0){const w=k(h,r,c),p=Math.round((w-r)*a),E=r+s*p;l+=h*(h-E),d+=(h-E)*(h-E)}}return(1-f)*l*l/i+f*d}static packAsBinary(t,e){for(let n=0;n<t.length;){let i=0;for(let c=7;c>=0&&n<t.length;c--){const s=t[n];if(s!==void 0){if(s!==0&&s!==1)throw new Error("1位量化值必须为0或1");i|=(s&1)<<c}n++}const r=Math.floor((n-1)/8);if(r>=e.length)throw new Error("打包数组长度不足");e[r]=i}}static discretize(t,e){return Math.floor((t+(e-1))/e)*e}static transposeHalfByte(t,e){if(!t||!e)throw new Error("输入数组不能为空");const n=t.length*4;if(e.length!==n)throw new Error(`转置数组长度不正确，期望${n}，实际${e.length}`);e.fill(0);const i=t.length;for(let r=0;r<t.length;r++){const c=t[r];if(c===void 0||c<0||c>15)throw new Error("4位量化值必须在0-15之间");const s=c&1,a=c>>1&1,f=c>>2&1,l=c>>3&1;e[r]=s,e[r+i]=a,e[r+i*2]=f,e[r+i*3]=l}}static transposeHalfByteOptimized(t,e,n=!0){if(n){const i=A.transposeCache.get(t);if(i){A.cacheStats.hits++,e.set(i);return}A.cacheStats.misses++}if(A.transposeHalfByte(t,e),n){const i=new Uint8Array(e);A.transposeCache.set(t,i)}}static transposeHalfByteFast(t,e){e.fill(0);let n=0;const i=t.length,c=e.length/4;for(;n<i;){let s=0,a=0,f=0,l=0;for(let u=7;u>=0&&n<i;u--){const h=t[n];s|=(h&1)<<u,a|=(h>>1&1)<<u,f|=(h>>2&1)<<u,l|=(h>>3&1)<<u,n++}const d=Math.floor((n+7)/8)-1;e[d]=s,e[d+c]=a,e[d+2*c]=f,e[d+3*c]=l}}static clearTransposeCache(){A.transposeCache=new WeakMap,A.cacheStats={hits:0,misses:0}}static getTransposeCacheStats(){const t=A.cacheStats.hits+A.cacheStats.misses;return{size:0,hitRate:t>0?A.cacheStats.hits/t:0}}};M(A,"transposeCache",new WeakMap),M(A,"cacheStats",{hits:0,misses:0});let R=A;function nt(o,t){if(o.length!==t.length)throw new Error(`向量长度不匹配：查询向量长度${o.length}，索引向量长度${t.length}`);let e=0;for(let n=0;n<o.length;n++){const i=o[n],r=t[n];i!==void 0&&r!==void 0&&(e+=i*r)}return e}function yt(o,t){return nt(o,t)}function It(o,t){return nt(o,t)}function $(o,t,e){switch(e){case"EUCLIDEAN":return St(o,t);case"COSINE":return Mt(o,t);case"MAXIMUM_INNER_PRODUCT":return zt(o,t);default:throw new Error(`不支持的相似性函数: ${e}`)}}function Ct(o,t){if(!o||!t)throw new Error("向量不能为空");if(o.length!==t.length)throw new Error("向量维度不匹配");let e=0;for(let n=0;n<o.length;n++){const i=o[n],r=t[n];if(i!==void 0&&r!==void 0){const c=i-r;e+=c*c}}return Math.sqrt(e)}function St(o,t){return 1/(1+Ct(o,t))}function Mt(o,t){if(!o||!t)throw new Error("向量不能为空");if(o.length!==t.length)throw new Error("向量维度不匹配");let e=0,n=0,i=0;for(let r=0;r<o.length;r++){const c=o[r],s=t[r];c!==void 0&&s!==void 0&&(e+=c*s,n+=c*c,i+=s*s)}return n===0||i===0?0:e/(Math.sqrt(n)*Math.sqrt(i))}function zt(o,t){let e=0;for(let n=0;n<o.length;n++){const i=o[n],r=t[n];i!==void 0&&r!==void 0&&(e+=i*r)}return e}function Nt(o){return o=o>>>0,o=o-(o>>>1&1431655765),o=(o&858993459)+(o>>>2&858993459),o=o+(o>>>4)&252645135,o=o+(o>>>8),o=o+(o>>>16),o&63}function At(o,t,e,n){const i=new Array(e).fill(0),r=Math.ceil(n/8),c=Math.floor(n/8);for(let s=0;s<e;s++){let a=0;const f=s*r;for(let d=0;d<c;d++){const u=t[f+d],h=d*8;a+=o[h]*(u>>7&1),a+=o[h+1]*(u>>6&1),a+=o[h+2]*(u>>5&1),a+=o[h+3]*(u>>4&1),a+=o[h+4]*(u>>3&1),a+=o[h+5]*(u>>2&1),a+=o[h+6]*(u>>1&1),a+=o[h+7]*(u&1)}const l=c*8;if(l<n){const d=t[f+c];for(let u=l;u<n;u++){const h=7-u%8,w=d>>h&1;a+=o[u]*w}}i[s]=a}return i}function Bt(o,t,e){const n=new Array(e).fill(0),i=o.length;for(let r=0;r<e;r++){let c=0;const s=r*i;for(let a=0;a<i;a++){const f=o[a],l=t[s+a],d=f&l;c+=Nt(d)}n[r]=c}return n}function J(o,t,e){const n=t.length,i=new Uint8Array(e*n);for(let r=0;r<n;r++){const c=o.vectorValue(t[r]),s=r*e;i.set(c,s)}return i}function Dt(o,t,e,n,i,r,c){const s=[];for(let a=0;a<n.length;a++){const f=o[a],l=e.getCorrectiveTerms(n[a]),d=l.quantizedComponentSum,u=l.lowerInterval,h=l.upperInterval-u,w=t.lowerInterval,p=t.upperInterval-w,E=t.quantizedComponentSum;let g=u*w*i+w*h*d+u*p*E+h*p*f;switch(c){case y.EUCLIDEAN:g=t.additionalCorrection+l.additionalCorrection-2*g,s.push(Math.max(1/(1+g),0));break;case y.COSINE:g+=t.additionalCorrection+l.additionalCorrection-r,s.push(Math.max((1+g)/2,0));break;case y.MAXIMUM_INNER_PRODUCT:g+=t.additionalCorrection+l.additionalCorrection-r,g<0?s.push(1/(1-g)):s.push(g+1);break;default:throw new Error(`不支持的相似性函数: ${c}`)}}return s}function bt(o,t,e,n,i,r,c){const s=[];for(let a=0;a<n.length;a++){const f=o[a],l=e.getCorrectiveTerms(n[a]),d=l.quantizedComponentSum,u=l.lowerInterval,h=l.upperInterval-u,w=t.lowerInterval,p=(t.upperInterval-w)*L,E=t.quantizedComponentSum;let g=u*w*i+w*h*d+u*p*E+h*p*f;switch(c){case y.EUCLIDEAN:const z=t.additionalCorrection+l.additionalCorrection-2*g;s.push(Math.max(1/(1+z),0));break;case y.COSINE:case y.MAXIMUM_INNER_PRODUCT:const I=g+t.additionalCorrection+l.additionalCorrection-r;c===y.MAXIMUM_INNER_PRODUCT?I<0?s.push(1/(1-I/L)):s.push(I/L+1):s.push(Math.max((1+I)/2,0));break;default:throw new Error(`不支持的相似性函数: ${c}`)}}return s}function Z(o){return o<0?1/(1-o):o+1}class Tt{constructor(t){M(this,"similarityFunction");this.similarityFunction=t}computeQuantizedScore(t,e,n,i,r,c){if(r===1)return this.computeOneBitQuantizedScore(t,e,n,i);if(r===4)return this.computeFourBitQuantizedScore(t,e,n,i,c);throw new Error(`不支持的查询位数: ${r}，只支持1位和4位`)}computeOneBitSimilarityScore(t,e,n,i,r){const c=n.quantizedComponentSum,s=n.lowerInterval,a=n.upperInterval-s,f=e.lowerInterval,l=e.upperInterval-f,d=e.quantizedComponentSum;let u=s*f*i+f*a*c+s*l*d+a*l*t;switch(this.similarityFunction){case y.EUCLIDEAN:return u=e.additionalCorrection+n.additionalCorrection-2*u,Math.max(1/(1+u),0);case y.COSINE:return u+=e.additionalCorrection+n.additionalCorrection-r,Math.max((1+u)/2,0);case y.MAXIMUM_INNER_PRODUCT:return u+=e.additionalCorrection+n.additionalCorrection-r,Z(u);default:throw new Error(`不支持的相似性函数: ${this.similarityFunction}`)}}computeFourBitSimilarityScore(t,e,n,i,r){const c=n.quantizedComponentSum,s=n.lowerInterval,a=n.upperInterval-s,f=e.lowerInterval,l=(e.upperInterval-f)*L,d=e.quantizedComponentSum,u=s*f*i+f*a*c+s*l*d+a*l*t;switch(this.similarityFunction){case y.EUCLIDEAN:const h=e.additionalCorrection+n.additionalCorrection-2*u;return Math.max(1/(1+h),0);case y.COSINE:case y.MAXIMUM_INNER_PRODUCT:const w=u+e.additionalCorrection+n.additionalCorrection-r;return this.similarityFunction===y.MAXIMUM_INNER_PRODUCT?Z(w):Math.max((1+w)/2,0);default:throw new Error(`不支持的相似性函数: ${this.similarityFunction}`)}}computeOneBitQuantizedScore(t,e,n,i){const r=n.getUnpackedVector(i),c=It(t,r),s=n.getCorrectiveTerms(i);return{score:this.computeOneBitSimilarityScore(c,e,s,n.dimension(),n.getCentroidDP()),bitDotProduct:c,corrections:{query:e,index:s}}}computeFourBitQuantizedScore(t,e,n,i,r){const c=n.getUnpackedVector(i),s=yt(t,c),a=n.getCorrectiveTerms(i);return{score:this.computeFourBitSimilarityScore(s,e,a,n.dimension(),r?n.getCentroidDP(r):0),bitDotProduct:s,corrections:{query:e,index:a}}}computeBatchQuantizedScores(t,e,n,i,r,c){try{let s;if(r===1){const l=Math.ceil(t.length/8),d=new Uint8Array(l);R.packAsBinary(t,d);const u=J(n,i,d.length);s=Bt(d,u,i.length)}else{const l=Math.ceil(n.dimension()/8),d=J(n,i,l);s=At(t,d,i.length,n.dimension())}let a;r===1?a=Dt(s,e,n,i,n.dimension(),n.getCentroidDP(),this.similarityFunction):a=bt(s,e,n,i,n.dimension(),n.getCentroidDP(c),this.similarityFunction);const f=[];for(let l=0;l<i.length;l++){const d=n.getCorrectiveTerms(i[l]);f.push({score:a[l],bitDotProduct:s[l],corrections:{query:e,index:d}})}return f}catch(s){console.warn("批量计算失败，回退到原始方法:",s);const a=[];for(const f of i){const l=this.computeQuantizedScore(t,e,n,f,r,c);a.push(l)}return a}}computeOriginalScore(t,e,n){switch(n){case y.EUCLIDEAN:return $(t,e,"EUCLIDEAN");case y.COSINE:return $(t,e,"COSINE");case y.MAXIMUM_INNER_PRODUCT:return $(t,e,"MAXIMUM_INNER_PRODUCT");default:throw new Error(`不支持的相似性函数: ${n}`)}}compareScores(t,e){const n=Math.abs(t-e);let i;t===0?i=e===0?0:1/0:i=n/Math.abs(t);const r=this.computeCorrelation(t,e);return{difference:n,relativeError:i,correlation:r}}computeCorrelation(t,e){if(t===e)return 1;if(t===0&&e!==0||t!==0&&e===0)return 0;if(t===0&&e===0)return 1;const n=t,i=e,r=t-n,c=e-i,s=r*c,a=Math.abs(r)*Math.abs(c);return a===0?0:s/a}computeQuantizationAccuracy(t,e){if(t.length!==e.length)throw new Error("原始分数和量化分数数组长度不匹配");const n=[];let i=0,r=0,c=1/0;for(let l=0;l<t.length;l++){const d=t[l],u=e[l];if(d!==void 0&&u!==void 0){const h=Math.abs(d-u);n.push(h),i+=h,r=Math.max(r,h),c=Math.min(c,h)}}const s=i/n.length,a=this.computeStandardDeviation(n,s),f=this.computePearsonCorrelation(t,e);return{meanError:s,maxError:r,minError:c,stdError:a,correlation:f}}computeStandardDeviation(t,e){let n=0;for(const i of t){const r=i-e;n+=r*r}return Math.sqrt(n/t.length)}computePearsonCorrelation(t,e){if(t.length!==e.length)throw new Error("数组长度不匹配");const n=t.length;let i=0,r=0,c=0,s=0,a=0;for(let d=0;d<n;d++){const u=t[d],h=e[d];u!==void 0&&h!==void 0&&(i+=u,r+=h,c+=u*h,s+=u*u,a+=h*h)}const f=n*c-i*r,l=Math.sqrt((n*s-i*i)*(n*a-r*r));return l===0?0:f/l}getSimilarityFunction(){return this.similarityFunction}}function V(o){let t=0;for(let n=0;n<o.length;n++){const i=o[n];i!==void 0&&(t+=i*i)}if(t=Math.sqrt(t),t===0)return new Float32Array(o.length);const e=new Float32Array(o.length);for(let n=0;n<o.length;n++){const i=o[n];i!==void 0&&(e[n]=i/t)}return e}function Ut(o){if(o.length===0)throw new Error("向量集合不能为空");const t=o[0];if(!t)throw new Error("第一个向量不能为空");const e=t.length,n=new Float32Array(e);for(let r=0;r<e;r++)n[r]=o[0][r]??0;for(let r=1;r<o.length;r++){const c=o[r];if(c)for(let s=0;s<e;s++){const a=c[s];a!==void 0&&(n[s]+=a)}}const i=o.length;for(let r=0;r<e;r++)n[r]/=i;return n}function H(o,t){if(o.length!==t.length)throw new Error("向量维度不匹配");let e=0;for(let n=0;n<o.length;n++){const i=o[n],r=t[n];i!==void 0&&r!==void 0&&(e+=i*r)}return e}class Rt{constructor(t=(e,n)=>e-n){M(this,"heap",[]);M(this,"compareFn");this.compareFn=t}size(){return this.heap.length}isEmpty(){return this.heap.length===0}peek(){return this.heap[0]}push(t){this.heap.push(t),this._bubbleUp()}pop(){if(this.isEmpty())return null;const t=this.heap[0],e=this.heap.pop();return this.heap.length>0&&(this.heap[0]=e,this._bubbleDown()),t}_bubbleUp(){let t=this.heap.length-1;for(;t>0;){const e=Math.floor((t-1)/2),n=this.heap[t],i=this.heap[e];if(this.compareFn(n,i)>=0)break;[this.heap[t],this.heap[e]]=[i,n],t=e}}_bubbleDown(){let t=0;for(;;){let e=t;const n=2*t+1,i=2*t+2;if(n<this.heap.length){const c=this.heap[n],s=this.heap[e];this.compareFn(c,s)<0&&(e=n)}if(i<this.heap.length){const c=this.heap[i],s=this.heap[e];this.compareFn(c,s)<0&&(e=i)}if(e===t)break;const r=this.heap[t];this.heap[t]=this.heap[e],this.heap[e]=r,t=e}}toArray(){return[...this.heap].sort(this.compareFn)}clear(){this.heap=[]}}class tt{constructor(t,e,n,i){M(this,"vectors");M(this,"unpackedVectors");M(this,"corrections");M(this,"centroid");M(this,"unpackedVectorCache");M(this,"maxCacheSize",1e4);this.vectors=t,this.unpackedVectors=e,this.corrections=n,this.centroid=i,this.unpackedVectorCache=new Map}dimension(){return this.centroid.length}size(){return this.vectors.length}vectorValue(t){const e=this.vectors[t];if(!e)throw new Error(`向量索引 ${t} 不存在`);return e}getUnpackedVector(t){const e=this.unpackedVectorCache.get(t);if(e)return e;const n=this.unpackedVectors[t];if(!n)throw new Error(`未打包向量索引 ${t} 不存在`);const i=new Uint8Array(n);if(this.unpackedVectorCache.set(t,i),this.unpackedVectorCache.size>this.maxCacheSize){const r=this.unpackedVectorCache.keys().next().value;r!==void 0&&this.unpackedVectorCache.delete(r)}return i}clearUnpackedVectorCache(){this.unpackedVectorCache.clear()}getCorrectiveTerms(t){const e=this.corrections[t];if(!e)throw new Error(`修正项索引 ${t} 不存在`);return e}getCentroidDP(t){return t?H(t,this.centroid):H(this.centroid,this.centroid)}getCentroid(){return this.centroid}}class Pt{constructor(t){M(this,"config");M(this,"quantizer");M(this,"scorer");if(t.queryBits!==void 0&&(t.queryBits<1||t.queryBits>8))throw new Error("queryBits必须在1-8之间");if(t.indexBits!==void 0&&(t.indexBits<1||t.indexBits>8))throw new Error("indexBits必须在1-8之间");this.config={queryBits:ut,indexBits:ht,...t},this.quantizer=new R(t.quantizer),this.scorer=new Tt(t.quantizer.similarityFunction)}quantizeVectors(t){if(t.length===0)throw new Error("向量集合不能为空");const e=this.config.quantizer.similarityFunction===y.COSINE?t.map(l=>V(l)):t,n=e[0];if(!n)throw new Error("第一个向量不能为空");const i=n.length;for(let l=1;l<e.length;l++){const d=e[l];if(!d)throw new Error(`向量 ${l} 不能为空`);if(d.length!==i)throw new Error(`向量 ${l} 维度 ${d.length} 与第一个向量维度 ${i} 不匹配`)}for(let l=0;l<e.length;l++){const d=e[l];if(d)for(let u=0;u<d.length;u++){const h=d[u];if(h!==void 0){if(isNaN(h))throw new Error(`向量 ${l} 位置 ${u} 包含NaN值`);if(!isFinite(h))throw new Error(`向量 ${l} 位置 ${u} 包含Infinity值`)}}}const r=Ut(e),c=[],s=[],a=[];for(const l of e){const d=new Float32Array(l),u=new Uint8Array(i),h=this.quantizer.scalarQuantize(d,u,this.config.indexBits,r);let w;this.config.indexBits===1?(w=new Uint8Array(Math.ceil(i/8)),R.packAsBinary(u,w),s.push(new Uint8Array(u))):(w=u,s.push(new Uint8Array(u))),c.push(w),a.push(h)}return{quantizedVectors:new tt(c,s,a,r),queryQuantizer:this.quantizer}}quantizeQueryVector(t,e){const n=this.config.quantizer.similarityFunction===y.COSINE?V(t):t,i=n.length,r=new Float32Array(n),c=new Uint8Array(i),s=this.quantizer.scalarQuantize(r,c,this.config.queryBits,e);return{quantizedQuery:c,queryCorrections:s}}searchNearestNeighbors(t,e,n){if(!t)throw new Error("查询向量不能为空");if(!e)throw new Error("目标向量集合不能为空");if(n<0)throw new Error("k值不能为负数");if(t.length!==e.dimension())throw new Error("查询向量维度与目标向量维度不匹配");if(n===0)return[];const i=this.config.quantizer.similarityFunction===y.COSINE?V(t):t,r=e.getCentroid(),{quantizedQuery:c,queryCorrections:s}=this.quantizeQueryVector(i,r),a=e.size(),f=new Float32Array(a),l=new Int32Array(a);for(let p=0;p<a;p++)l[p]=p;const d=1e3;for(let p=0;p<a;p+=d){const E=Math.min(p+d,a),g=Array.from({length:E-p},(I,N)=>p+N),z=this.scorer.computeBatchQuantizedScores(c,s,e,g,this.config.queryBits);for(let I=0;I<z.length;I++){const N=z[I];N&&(f[p+I]=N.score)}}const u=new Rt((p,E)=>p.score-E.score),h=Math.min(n,a);for(let p=0;p<a;p++){const E=f[p];if(E!==void 0)if(u.size()<h)u.push({score:E,index:l[p]});else{const g=u.peek();g&&E>g.score&&(u.pop(),u.push({score:E,index:l[p]}))}}const w=[];for(;!u.isEmpty();){const p=u.pop();p&&w.push(p)}return w.reverse(),w}computeQuantizationAccuracy(t,e){if(t.length===0)throw new Error("原始向量集合不能为空");if(e.length===0)throw new Error("查询向量集合不能为空");if(t.length!==e.length)throw new Error("原始向量集合和查询向量集合长度不匹配");const{quantizedVectors:n}=this.quantizeVectors(t),i=[],r=[];for(const c of e){const s=n.getCentroid(),{quantizedQuery:a,queryCorrections:f}=this.quantizeQueryVector(c,s),l=this.scorer.computeQuantizedScore(a,f,n,0,this.config.queryBits);r.push(l.score);const d=this.scorer.computeOriginalScore(c,t[0],this.config.quantizer.similarityFunction);i.push(d)}return this.scorer.computeQuantizationAccuracy(i,r)}serializeVectorData(t){const{quantizedVectors:e}=this.quantizeVectors(t),n=e.getCentroid(),i=[],r=e.size();for(let s=0;s<r;s++){const a=e.vectorValue(s),f=e.getCorrectiveTerms(s),l=new Uint8Array(Math.ceil(a.length/8));R.packAsBinary(a,l),i.push({binaryValues:l,lowerInterval:f.lowerInterval,upperInterval:f.upperInterval,additionalCorrection:f.additionalCorrection,quantizedComponentSum:f.quantizedComponentSum})}const c={fieldNumber:0,vectorEncodingOrdinal:0,vectorSimilarityOrdinal:0,dimensions:n.length,vectorDataOffset:0,vectorDataLength:0,vectorCount:r,centroid:n,centroidSquareMagnitude:H(n,n)};return{vectorData:i,metadata:c}}deserializeVectorData(t,e){const n=[],i=[];for(const r of t){const c=new Uint8Array(e.dimensions);this.unpackBinaryValues(r.binaryValues,c),n.push(c),i.push({lowerInterval:r.lowerInterval,upperInterval:r.upperInterval,additionalCorrection:r.additionalCorrection,quantizedComponentSum:r.quantizedComponentSum})}return new tt(n,n,i,e.centroid)}unpackBinaryValues(t,e){let n=0;for(let i=0;i<t.length;i++){const r=t[i];if(r!==void 0)for(let c=7;c>=0&&n<e.length;c--)e[n++]=r>>c&1}}getConfig(){return this.config}getQuantizer(){return this.quantizer}getScorer(){return this.scorer}}y.COSINE;function F(o){const t=new Float32Array(o);for(let e=0;e<o;e++)t[e]=Math.random()*2-1;return t}function x(){return"memory"in performance&&performance.memory?performance.memory.usedJSHeapSize:0}function W(){const o=document.getElementById("memoryWarning");o&&x()===0&&(o.style.display="block")}function kt(o,t){let e=0,n=0,i=0;for(let r=0;r<o.length;r++)e+=o[r]*t[r],n+=o[r]*o[r],i+=t[r]*t[r];return e/(Math.sqrt(n)*Math.sqrt(i))}async function ot(o){const{dimension:t,vectorCount:e,queryCount:n,bits:i}=o;"gc"in globalThis&&globalThis.gc();const r=x(),c=performance.now(),s=[];for(let g=0;g<e;g++)s.push(F(t));const a=new Pt({queryBits:i,indexBits:1,quantizer:{similarityFunction:y.COSINE,lambda:.1,iters:5}}),{quantizedVectors:f}=a.quantizeVectors(s),l=[];let d=0;const u=10;for(let g=0;g<n;g++){const z=F(t),I=performance.now(),N=a.searchNearestNeighbors(z,f,u);l.push(performance.now()-I);const m=s.map((C,D)=>({idx:D,score:kt(z,C)})).sort((C,D)=>D.score-C.score).slice(0,u).map(C=>C.idx),v=new Set(N.map(C=>C.index)),S=m.filter(C=>v.has(C)).length;d+=S/u}const h=performance.now()-c,w=l.reduce((g,z)=>g+z,0)/l.length,p=d/n*100;await new Promise(g=>setTimeout(g,100));const E=x();return{name:"TypeScript",avgTime:w,totalTime:h,memoryBefore:r,memoryAfter:E,memoryDelta:E-r,vectorsProcessed:e,recallRate:p}}async function rt(o){const{dimension:t,vectorCount:e,queryCount:n,bits:i}=o;"gc"in globalThis&&globalThis.gc();const r=x(),c=performance.now();try{const{WasmProvider:s,WasmScalarQuantizer:a,wasm_compute_similarity:f}=await lt(async()=>{const{WasmProvider:m,WasmScalarQuantizer:v,wasm_compute_similarity:S}=await import("./index-9no2z925.js");return{WasmProvider:m,WasmScalarQuantizer:v,wasm_compute_similarity:S}},[],import.meta.url);s.isInitialized()||await s.init();const l=[];for(let m=0;m<e;m++)l.push(F(t));const d=new Float32Array(t);for(let m=0;m<t;m++){let v=0;for(const S of l)v+=S[m];d[m]=v/l.length}const u=new a(.1,5,"cosine"),h=l.map(m=>u.scalar_quantize(m,i,d)),w=[];let p=0;const E=10;for(let m=0;m<n;m++){const v=F(t),S=performance.now(),C=u.scalar_quantize(v,i,d);w.push(performance.now()-S);const U=h.map((B,T)=>({idx:T,score:-Math.abs(B.correction-C.correction)})).sort((B,T)=>T.score-B.score).slice(0,E).map(B=>B.idx),q=l.map((B,T)=>({idx:T,score:f(v,B,"cosine")})).sort((B,T)=>T.score-B.score).slice(0,E).map(B=>B.idx),K=new Set(U),b=q.filter(B=>K.has(B)).length;p+=b/E}const g=performance.now()-c,z=w.reduce((m,v)=>m+v,0)/w.length,I=p/n*100;await new Promise(m=>setTimeout(m,100));const N=x();return{name:"Rust WASM",avgTime:z,totalTime:g,memoryBefore:r,memoryAfter:N,memoryDelta:N-r,vectorsProcessed:e,recallRate:I}}catch(s){throw console.error("WASM test error:",s),s}}function X(o){if(o===0)return"N/A";const t=1024,e=["Bytes","KB","MB","GB"],n=Math.floor(Math.log(o)/Math.log(t));return Math.round(o/Math.pow(t,n)*100)/100+" "+e[n]}function et(o){return o.toFixed(2)+" ms"}function _(o){const t=document.getElementById("results"),e=o.name==="TypeScript"?"ts":"rust",n=document.createElement("div");n.className=`result-card ${e}`;const i=o.recallRate!==void 0?`<div class="result-item">
      <span class="result-label">召回率 (Recall@10)</span>
      <span class="result-value">${o.recallRate.toFixed(2)}%</span>
    </div>`:"";n.innerHTML=`
    <h3>${o.name} 版本</h3>
    <div class="result-item">
      <span class="result-label">平均查询时间</span>
      <span class="result-value">${et(o.avgTime)}</span>
    </div>
    <div class="result-item">
      <span class="result-label">总执行时间</span>
      <span class="result-value">${et(o.totalTime)}</span>
    </div>
    ${i}
    <div class="result-item">
      <span class="result-label">初始内存</span>
      <span class="result-value">${X(o.memoryBefore)}</span>
    </div>
    <div class="result-item">
      <span class="result-label">最终内存</span>
      <span class="result-value">${X(o.memoryAfter)}</span>
    </div>
    <div class="result-item">
      <span class="result-label">内存增量</span>
      <span class="result-value">${X(o.memoryDelta)}</span>
    </div>
    <div class="result-item">
      <span class="result-label">处理向量数</span>
      <span class="result-value">${o.vectorsProcessed.toLocaleString()}</span>
    </div>
  `,t.appendChild(n)}function O(){return{dimension:parseInt(document.getElementById("dimension").value),vectorCount:parseInt(document.getElementById("vectorCount").value),queryCount:parseInt(document.getElementById("queryCount").value),bits:parseInt(document.getElementById("bits").value)}}function P(o){const t=document.getElementById("loading");t.className=o?"loading active":"loading"}function j(){document.getElementById("results").innerHTML=""}document.getElementById("runTS").addEventListener("click",async()=>{j(),P(!0);try{const o=await ot(O());_(o),W()}catch(o){console.error("TypeScript test failed:",o),alert("TypeScript 测试失败: "+o)}finally{P(!1)}});document.getElementById("runRust").addEventListener("click",async()=>{j(),P(!0);try{const o=await rt(O());_(o),W()}catch(o){console.error("Rust test failed:",o),alert("Rust 测试失败: "+o)}finally{P(!1)}});document.getElementById("runBoth").addEventListener("click",async()=>{j(),P(!0);try{const o=O(),t=await ot(o);_(t),await new Promise(n=>setTimeout(n,500));const e=await rt(O());_(e),W()}catch(o){console.error("Comparison test failed:",o),alert("对比测试失败: "+o)}finally{P(!1)}});console.log("Demo ready. Click a button to start testing!");
