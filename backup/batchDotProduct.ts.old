/**
 * 批量点积计算模块
 * 实现高效的批量点积计算，支持八路循环展开优化
 * 基于Lucene的二值量化实现
 */

import type { QuantizationResult } from './types';
import { VectorSimilarityFunction } from './types';
import { computeInt1BitDotProduct } from './bitwiseDotProduct';
import { FOUR_BIT_SCALE } from './constants';

/**
 * 超向量化位计数算法 - 专门为32位整数优化
 * @param n 32位整数
 * @returns 1的个数
 */
function bitCount32Optimized(n: number): number {
  n = n >>> 0;
  n = n - ((n >>> 1) & 0x55555555);
  n = (n & 0x33333333) + ((n >>> 2) & 0x33333333);
  n = (n + (n >>> 4)) & 0x0F0F0F0F;
  n = n + (n >>> 8);
  n = n + (n >>> 16);
  return n & 0x3F;
}

/**
 * 超向量化批量点积计算 - 使用Uint32Array一次处理4个字节
 * 这是真正的向量化批量操作，避免了逐字节循环
 * @param queryVector 查询向量
 * @param concatenatedBuffer 连接的目标向量缓冲区
 * @param numVectors 向量数量
 * @param dimension 向量维度
 * @returns 点积结果数组
 */
export function computeBatchDotProductUltraVectorized(
  queryVector: Uint8Array,
  concatenatedBuffer: Uint8Array,
  numVectors: number,
  dimension: number
): number[] {
  const results: number[] = new Array(numVectors).fill(0);
  const bytesPerVector = queryVector.length;
  const queryLength = queryVector.length;
  
  // 使用Uint32Array视图来一次处理4个字节
  const uint32Length = Math.floor(queryLength / 4);
  const remainderStart = uint32Length * 4;
  
  // 创建查询向量的Uint32Array视图
  const query32 = new Uint32Array(queryVector.buffer, queryVector.byteOffset, uint32Length);
  
  for (let vecIndex = 0; vecIndex < numVectors; vecIndex++) {
    let currentDotProduct = 0;
    const vectorOffset = vecIndex * bytesPerVector;
    
    // 创建当前目标向量的Uint32Array视图
    const target32 = new Uint32Array(concatenatedBuffer.buffer, concatenatedBuffer.byteOffset + vectorOffset, uint32Length);
    
    // 向量化处理：一次处理4个字节
    for (let i = 0; i < uint32Length; i++) {
      // 使用直接乘法而不是按位与，与现有算法保持一致
      const query32Val = query32[i]!;
      const target32Val = target32[i]!;
      
      // 将32位值分解为4个8位值进行乘法
      const q0 = (query32Val & 0xFF);
      const q1 = ((query32Val >> 8) & 0xFF);
      const q2 = ((query32Val >> 16) & 0xFF);
      const q3 = ((query32Val >> 24) & 0xFF);
      
      const t0 = (target32Val & 0xFF);
      const t1 = ((target32Val >> 8) & 0xFF);
      const t2 = ((target32Val >> 16) & 0xFF);
      const t3 = ((target32Val >> 24) & 0xFF);
      
      currentDotProduct += (q0 * t0 + q1 * t1 + q2 * t2 + q3 * t3);
    }
    
    // 处理剩余的字节（如果有的话）
    for (let i = remainderStart; i < queryLength; i++) {
      const queryByte = queryVector[i]!;
      const dataByte = concatenatedBuffer[vectorOffset + i]!;
      currentDotProduct += queryByte * dataByte;
    }
    
    results[vecIndex] = currentDotProduct;
  }
  
  return results;
}

/**
 * 超向量化批量点积计算（4位量化版本）
 * 4位量化查询向量与1位量化索引向量的超向量化批量点积计算
 * @param queryVector 4位量化查询向量
 * @param concatenatedBuffer 连接的目标向量缓冲区
 * @param numVectors 向量数量
 * @param dimension 向量维度
 * @returns 点积结果数组
 */
export function computeBatchFourBitDotProductUltraVectorized(
  queryVector: Uint8Array,
  concatenatedBuffer: Uint8Array,
  numVectors: number,
  dimension: number
): number[] {
  const results: number[] = new Array(numVectors).fill(0);
  const bytesPerVector = queryVector.length;
  const queryLength = queryVector.length;
  
  // 使用Uint32Array视图来一次处理4个字节
  const uint32Length = Math.floor(queryLength / 4);
  const remainderStart = uint32Length * 4;
  
  // 创建查询向量的Uint32Array视图
  const query32 = new Uint32Array(queryVector.buffer, queryVector.byteOffset, uint32Length);
  
  for (let vecIndex = 0; vecIndex < numVectors; vecIndex++) {
    let currentDotProduct = 0;
    const vectorOffset = vecIndex * bytesPerVector;
    
    // 创建当前目标向量的Uint32Array视图
    const target32 = new Uint32Array(concatenatedBuffer.buffer, concatenatedBuffer.byteOffset + vectorOffset, uint32Length);
    
    // 向量化处理：一次处理4个字节
    for (let i = 0; i < uint32Length; i++) {
      // 使用直接乘法而不是按位与，与现有算法保持一致
      const query32Val = query32[i]!;
      const target32Val = target32[i]!;
      
      // 将32位值分解为4个8位值进行乘法
      const q0 = (query32Val & 0xFF);
      const q1 = ((query32Val >> 8) & 0xFF);
      const q2 = ((query32Val >> 16) & 0xFF);
      const q3 = ((query32Val >> 24) & 0xFF);
      
      const t0 = (target32Val & 0xFF);
      const t1 = ((target32Val >> 8) & 0xFF);
      const t2 = ((target32Val >> 16) & 0xFF);
      const t3 = ((target32Val >> 24) & 0xFF);
      
      currentDotProduct += (q0 * t0 + q1 * t1 + q2 * t2 + q3 * t3);
    }
    
    // 处理剩余的字节（如果有的话）
    for (let i = remainderStart; i < queryLength; i++) {
      const queryByte = queryVector[i]!;
      const dataByte = concatenatedBuffer[vectorOffset + i]!;
      currentDotProduct += queryByte * dataByte;
    }
    
    results[vecIndex] = currentDotProduct;
  }
  
  return results;
}

/**
 * 八路循环展开的批量点积计算（适用于1位量化）
 * 将所有二值化向量连接成一个大缓冲区，使用八路循环展开进行高效计算
 * @param queryVector 查询向量
 * @param concatenatedBuffer 连接的目标向量缓冲区
 * @param numVectors 向量数量
 * @param dimension 向量维度
 * @returns 点积结果数组
 */
export function computeBatchDotProductOptimized(
  queryVector: Uint8Array,
  concatenatedBuffer: Uint8Array,
  numVectors: number,
  dimension: number
): number[] {
  const results: number[] = new Array(numVectors).fill(0);
  const bytesPerVector = queryVector.length;
  const queryLength = queryVector.length;
  const loopCount = Math.floor(queryLength / 8) * 8;
  const remainingStart = loopCount;
  
  for (let vecIndex = 0; vecIndex < numVectors; vecIndex++) {
    let currentDotProduct = 0;
    const vectorOffset = vecIndex * bytesPerVector;
    
    // 主循环：每次处理8个字节
    for (let i = 0; i < loopCount; i += 8) {
      const offset = vectorOffset + i;
      const queryByte0 = queryVector[i]!;
      const dataByte0 = concatenatedBuffer[offset]!;
      const queryByte1 = queryVector[i + 1]!;
      const dataByte1 = concatenatedBuffer[offset + 1]!;
      const queryByte2 = queryVector[i + 2]!;
      const dataByte2 = concatenatedBuffer[offset + 2]!;
      const queryByte3 = queryVector[i + 3]!;
      const dataByte3 = concatenatedBuffer[offset + 3]!;
      const queryByte4 = queryVector[i + 4]!;
      const dataByte4 = concatenatedBuffer[offset + 4]!;
      const queryByte5 = queryVector[i + 5]!;
      const dataByte5 = concatenatedBuffer[offset + 5]!;
      const queryByte6 = queryVector[i + 6]!;
      const dataByte6 = concatenatedBuffer[offset + 6]!;
      const queryByte7 = queryVector[i + 7]!;
      const dataByte7 = concatenatedBuffer[offset + 7]!;
      
      // 并行计算8个字节的直接点积
      currentDotProduct += (
        queryByte0 * dataByte0 +
        queryByte1 * dataByte1 +
        queryByte2 * dataByte2 +
        queryByte3 * dataByte3 +
        queryByte4 * dataByte4 +
        queryByte5 * dataByte5 +
        queryByte6 * dataByte6 +
        queryByte7 * dataByte7
      );
    }
    
    // 处理剩余的字节
    for (let i = remainingStart; i < queryLength; i++) {
      const queryByte = queryVector[i]!;
      const dataByte = concatenatedBuffer[vectorOffset + i]!;
      currentDotProduct += queryByte * dataByte;
    }
    
    results[vecIndex] = currentDotProduct;
  }
  
  return results;
}

/**
 * 八路循环展开的4位量化批量点积计算
 * 4位量化查询向量与1位量化索引向量的批量点积计算
 * @param queryVector 4位量化查询向量
 * @param concatenatedBuffer 连接的目标向量缓冲区
 * @param numVectors 向量数量
 * @param dimension 向量维度
 * @returns 点积结果数组
 */
export function computeBatchFourBitDotProductOptimized(
  queryVector: Uint8Array,
  concatenatedBuffer: Uint8Array,
  numVectors: number,
  dimension: number
): number[] {
  const results: number[] = new Array(numVectors).fill(0);
  const bytesPerVector = queryVector.length;
  const queryLength = queryVector.length;
  const loopCount = Math.floor(queryLength / 8) * 8;
  const remainingStart = loopCount;
  
  for (let vecIndex = 0; vecIndex < numVectors; vecIndex++) {
    let currentDotProduct = 0;
    const vectorOffset = vecIndex * bytesPerVector;
    
    // 主循环：每次处理8个字节
    for (let i = 0; i < loopCount; i += 8) {
      const offset = vectorOffset + i;
      const queryByte0 = queryVector[i]!;
      const dataByte0 = concatenatedBuffer[offset]!;
      const queryByte1 = queryVector[i + 1]!;
      const dataByte1 = concatenatedBuffer[offset + 1]!;
      const queryByte2 = queryVector[i + 2]!;
      const dataByte2 = concatenatedBuffer[offset + 2]!;
      const queryByte3 = queryVector[i + 3]!;
      const dataByte3 = concatenatedBuffer[offset + 3]!;
      const queryByte4 = queryVector[i + 4]!;
      const dataByte4 = concatenatedBuffer[offset + 4]!;
      const queryByte5 = queryVector[i + 5]!;
      const dataByte5 = concatenatedBuffer[offset + 5]!;
      const queryByte6 = queryVector[i + 6]!;
      const dataByte6 = concatenatedBuffer[offset + 6]!;
      const queryByte7 = queryVector[i + 7]!;
      const dataByte7 = concatenatedBuffer[offset + 7]!;
      
      // 并行计算8个字节的直接点积
      currentDotProduct += (
        queryByte0 * dataByte0 +
        queryByte1 * dataByte1 +
        queryByte2 * dataByte2 +
        queryByte3 * dataByte3 +
        queryByte4 * dataByte4 +
        queryByte5 * dataByte5 +
        queryByte6 * dataByte6 +
        queryByte7 * dataByte7
      );
    }
    
    // 处理剩余的字节
    for (let i = remainingStart; i < queryLength; i++) {
      const queryByte = queryVector[i]!;
      const dataByte = concatenatedBuffer[vectorOffset + i]!;
      currentDotProduct += queryByte * dataByte;
    }
    
    results[vecIndex] = currentDotProduct;
  }
  
  return results;
}

/**
 * 真正的原始算法：逐个调用computeInt1BitDotProduct
 * @param queryVector 查询向量
 * @param targetVectors 目标向量集合
 * @param targetOrds 目标向量序号数组
 * @returns 点积结果数组
 */
export function computeBatchDotProductTrueOriginal(
  queryVector: Uint8Array,
  targetVectors: { getUnpackedVector: (ord: number) => Uint8Array },
  targetOrds: number[]
): number[] {
  const results: number[] = new Array(targetOrds.length).fill(0);
  
  for (let i = 0; i < targetOrds.length; i++) {
    const unpackedBinaryCode = targetVectors.getUnpackedVector(targetOrds[i]!);
    results[i] = computeInt1BitDotProduct(queryVector, unpackedBinaryCode);
  }
  
  return results;
}

/**
 * 批量点积计算的原始方法（直接点积计算）
 * @param queryVector 查询向量
 * @param concatenatedBuffer 连接的目标向量缓冲区
 * @param numVectors 向量数量
 * @param dimension 向量维度
 * @returns 点积结果数组
 */
export function computeBatchDotProductOriginal(
  queryVector: Uint8Array,
  concatenatedBuffer: Uint8Array,
  numVectors: number,
  dimension: number
): number[] {
  const results: number[] = new Array(numVectors).fill(0);
  const bytesPerVector = queryVector.length;
  const queryLength = queryVector.length;
  
  for (let vecIndex = 0; vecIndex < numVectors; vecIndex++) {
    let currentDotProduct = 0;
    const vectorOffset = vecIndex * bytesPerVector;
    
    for (let i = 0; i < queryLength; i++) {
      const queryByte = queryVector[i]!;
      const dataByte = concatenatedBuffer[vectorOffset + i]!;
      
      // 直接点积计算
      currentDotProduct += queryByte * dataByte;
    }
    
    results[vecIndex] = currentDotProduct;
  }
  
  return results;
}

/**
 * 创建连接的目标向量缓冲区
 * 将所有目标向量连接成一个大的连续缓冲区，用于批量计算
 * @param targetVectors 目标向量集合
 * @param targetOrds 目标向量序号数组
 * @returns 连接的目标向量缓冲区
 */
export function createConcatenatedBuffer(
  targetVectors: { getUnpackedVector: (ord: number) => Uint8Array },
  targetOrds: number[]
): Uint8Array {
  if (targetOrds.length === 0) {
    return new Uint8Array(0);
  }
  
  // 获取第一个向量的长度作为基准
  const firstVector = targetVectors.getUnpackedVector(targetOrds[0]!);
  const vectorLength = firstVector.length;
  const totalLength = vectorLength * targetOrds.length;
  
  // 创建连接缓冲区
  const concatenatedBuffer = new Uint8Array(totalLength);
  
  // 连接所有向量
  for (let i = 0; i < targetOrds.length; i++) {
    const vector = targetVectors.getUnpackedVector(targetOrds[i]!);
    const offset = i * vectorLength;
    concatenatedBuffer.set(vector, offset);
  }
  
  return concatenatedBuffer;
}

/**
 * 构造直接打包算法的连续buffer
 * 将打包向量直接复制到连续buffer中，避免解包开销
 * @param targetVectors 目标向量集合（包含打包向量）
 * @param targetOrds 目标向量序号数组
 * @param vectorSize 向量大小
 * @returns 连续buffer
 */
export function createDirectPackedBuffer(
  targetVectors: { vectorValue: (ord: number) => Uint8Array },
  targetOrds: number[],
  vectorSize: number
): Uint8Array {
  const numVectors = targetOrds.length;
  const continuousBuffer = new Uint8Array(vectorSize * numVectors);
  
  // 将打包向量直接复制到连续buffer中
  for (let i = 0; i < numVectors; i++) {
    const targetVector = targetVectors.vectorValue(targetOrds[i]!);
    const offset = i * vectorSize;
    continuousBuffer.set(targetVector, offset);
  }
  
  return continuousBuffer;
}

/**
 * 直接处理打包向量的超向量化批量点积计算
 * 使用预构造的连续buffer进行计算，避免解包开销
 * 对于单比特数据，使用按位与+位计数
 * @param queryVector 查询向量（已打包）
 * @param continuousBuffer 预构造的连续buffer
 * @param numVectors 向量数量
 * @param dimension 向量维度
 * @returns 点积结果数组
 */
export function computeBatchDotProductDirectPacked(
  queryVector: Uint8Array,
  continuousBuffer: Uint8Array,
  numVectors: number,
  dimension: number
): number[] {
  const results: number[] = new Array(numVectors).fill(0);
  const queryLength = queryVector.length;
  
  for (let vecIndex = 0; vecIndex < numVectors; vecIndex++) {
    let currentDotProduct = 0;
    const vectorOffset = vecIndex * queryLength;
    
    // 处理打包后的数据（每个字节0-255）
    // 使用按位与+位计数
    for (let i = 0; i < queryLength; i++) {
      const queryByte = queryVector[i]!;
      const targetByte = continuousBuffer[vectorOffset + i]!;
      
      // 按位与，然后计算1的个数
      const andResult = queryByte & targetByte;
      currentDotProduct += bitCount32Optimized(andResult);
    }
    
    results[vecIndex] = currentDotProduct;
  }
  
  return results;
}

/**
 * 构造直接打包算法的连续buffer（4位量化版本）
 * @param targetVectors 目标向量集合（包含打包向量）
 * @param targetOrds 目标向量序号数组
 * @param vectorSize 向量大小
 * @returns 连续buffer
 */
export function createDirectPackedBufferFourBit(
  targetVectors: { vectorValue: (ord: number) => Uint8Array },
  targetOrds: number[],
  vectorSize: number
): Uint8Array {
  // 4位量化：直接使用打包的1位量化向量，不解包！
  const packedVectorSize = Math.ceil(vectorSize / 8);
  const totalSize = targetOrds.length * packedVectorSize;
  const buffer = new Uint8Array(totalSize);
  
  for (let i = 0; i < targetOrds.length; i++) {
    const packedVector = targetVectors.vectorValue(targetOrds[i]!);
    const offset = i * packedVectorSize;
    
    // 直接复制打包的向量数据，不解包！
    buffer.set(packedVector, offset);
  }
  
  return buffer;
}

/**
 * 正确的4位批量点积算法（查询未打包，目标打包）
 * @param queryVector 4位量化查询向量 (未打包, 每字节1个值)
 * @param continuousBuffer 1位量化目标向量的连续打包buffer
 * @param numVectors 向量数量
 * @param dimension 向量维度
 * @returns 点积结果数组
 */
export function computeBatchFourBitDotProductDirectPacked(
  queryVector: Uint8Array,
  continuousBuffer: Uint8Array,
  numVectors: number,
  dimension: number
): number[] {
  const results: number[] = new Array(numVectors).fill(0);
  const packedDimension = Math.ceil(dimension / 8);

  for (let vecIndex = 0; vecIndex < numVectors; vecIndex++) {
    let currentDotProduct = 0;
    const targetOffset = vecIndex * packedDimension;

    for (let dim = 0; dim < dimension; dim++) {
      // 查询向量是未打包的, 直接按索引取值
      const queryValue = queryVector[dim]!;

      // 目标向量是打包的, 需要通过位运算取值
      const targetByteIndex = Math.floor(dim / 8);
      const targetBitIndex = 7 - (dim % 8);
      const targetByte = continuousBuffer[targetOffset + targetByteIndex]!;
      const targetValue = (targetByte >> targetBitIndex) & 1;

      // 直接相乘并累加
      currentDotProduct += queryValue * targetValue;
    }
    results[vecIndex] = currentDotProduct;
  }
  return results;
}

/**
 * 批量计算1位量化相似性分数
 * @param qcDists 批量点积结果
 * @param queryCorrections 查询向量修正因子
 * @param targetVectors 目标向量集合
 * @param targetOrds 目标向量序号数组
 * @param dimension 向量维度
 * @param centroidDP 质心点积
 * @param similarityFunction 相似性函数
 * @returns 相似性分数数组
 */
export function computeBatchOneBitSimilarityScores(
  qcDists: number[],
  queryCorrections: QuantizationResult,
  targetVectors: { getCorrectiveTerms: (ord: number) => QuantizationResult },
  targetOrds: number[],
  dimension: number,
  centroidDP: number,
  similarityFunction: VectorSimilarityFunction
): number[] {
  const scores: number[] = [];
  
  for (let i = 0; i < targetOrds.length; i++) {
    const qcDist = qcDists[i]!;
    const indexCorrections = targetVectors.getCorrectiveTerms(targetOrds[i]!);
    
    // 按照Lucene二值量化原始实现计算分数
    const x1 = indexCorrections.quantizedComponentSum;
    const ax = indexCorrections.lowerInterval;
    const lx = indexCorrections.upperInterval - ax;
    const ay = queryCorrections.lowerInterval;
    const ly = queryCorrections.upperInterval - ay;
    const y1 = queryCorrections.quantizedComponentSum;

    // 计算基础分数
    let score = ax * ay * dimension +
      ay * lx * x1 +
      ax * ly * y1 +
      lx * ly * qcDist;

    // 根据相似性函数调整分数
    switch (similarityFunction) {
      case VectorSimilarityFunction.EUCLIDEAN:
        score = queryCorrections.additionalCorrection +
          indexCorrections.additionalCorrection -
          2 * score;
        scores.push(Math.max(1 / (1 + score), 0));
        break;

      case VectorSimilarityFunction.COSINE:
        score += queryCorrections.additionalCorrection +
          indexCorrections.additionalCorrection -
          centroidDP;
        scores.push(Math.max((1 + score) / 2, 0));
        break;

      case VectorSimilarityFunction.MAXIMUM_INNER_PRODUCT:
        score += queryCorrections.additionalCorrection +
          indexCorrections.additionalCorrection -
          centroidDP;
        // 1位量化：不使用FOUR_BIT_SCALE
        if (score < 0) {
          scores.push(1 / (1 - score));
        } else {
          scores.push(score + 1);
        }
        break;

      default:
        throw new Error(`不支持的相似性函数: ${similarityFunction}`);
    }
  }
  
  return scores;
}

/**
 * 批量计算4位量化相似性分数
 * @param qcDists 批量点积结果
 * @param queryCorrections 查询向量修正因子
 * @param targetVectors 目标向量集合
 * @param targetOrds 目标向量序号数组
 * @param dimension 向量维度
 * @param centroidDP 质心点积
 * @param similarityFunction 相似性函数
 * @returns 相似性分数数组
 */
export function computeBatchFourBitSimilarityScores(
  qcDists: number[],
  queryCorrections: QuantizationResult,
  targetVectors: { getCorrectiveTerms: (ord: number) => QuantizationResult },
  targetOrds: number[],
  dimension: number,
  centroidDP: number,
  similarityFunction: VectorSimilarityFunction
): number[] {
  const scores: number[] = [];
  
  for (let i = 0; i < targetOrds.length; i++) {
    const qcDist = qcDists[i]!;
    const indexCorrections = targetVectors.getCorrectiveTerms(targetOrds[i]!);
    
    // 按照Lucene二值量化原始实现计算分数
    const x1 = indexCorrections.quantizedComponentSum;
    const ax = indexCorrections.lowerInterval;
    const lx = indexCorrections.upperInterval - ax;
    const ay = queryCorrections.lowerInterval;
    const ly = (queryCorrections.upperInterval - ay) * FOUR_BIT_SCALE; // 4位量化使用FOUR_BIT_SCALE
    const y1 = queryCorrections.quantizedComponentSum;

    // 计算基础分数
    let score = ax * ay * dimension +
      ay * lx * x1 +
      ax * ly * y1 +
      lx * ly * qcDist;

    // 根据相似性函数调整分数
    switch (similarityFunction) {
      case VectorSimilarityFunction.EUCLIDEAN:
        const euclideanScore = queryCorrections.additionalCorrection +
          indexCorrections.additionalCorrection -
          2 * score;
        scores.push(Math.max(1 / (1 + euclideanScore), 0));
        break;

      case VectorSimilarityFunction.COSINE:
      case VectorSimilarityFunction.MAXIMUM_INNER_PRODUCT:
        const adjustedScore = score + queryCorrections.additionalCorrection +
          indexCorrections.additionalCorrection -
          centroidDP;

        if (similarityFunction === VectorSimilarityFunction.MAXIMUM_INNER_PRODUCT) {
          // 使用scaleMaxInnerProductScore函数
          if (adjustedScore < 0) {
            scores.push(1 / (1 - adjustedScore / FOUR_BIT_SCALE));
          } else {
            scores.push(adjustedScore / FOUR_BIT_SCALE + 1);
          }
        } else {
          // COSINE
          scores.push(Math.max((1 + adjustedScore) / 2, 0));
        }
        break;

      default:
        throw new Error(`不支持的相似性函数: ${similarityFunction}`);
    }
  }
  
  return scores;
} 