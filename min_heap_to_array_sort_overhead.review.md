## 问题名：`min_heap_to_array_sort_overhead.review.md`

**详细描述：**
在 `src/minHeap.ts` 文件的 `MinHeap` 类中，`toArray()` 方法用于将堆转换为一个排序后的数组：
```typescript
  toArray(): T[] {
    return [...this.heap].sort(this.compareFn);
  }
```
这个方法首先创建了内部 `heap` 数组的一个浅拷贝 (`[...this.heap]`)，然后对这个拷贝使用 `sort()` 方法进行排序。排序操作的时间复杂度是 O(N log N)，其中 N 是堆中元素的数量。

如果 `toArray()` 方法被频繁调用，或者堆中包含大量元素，那么这个排序操作会成为一个显著的性能瓶颈。堆的主要优势在于高效地获取最小（或最大）元素，而不是提供一个完全排序的列表。

**解决方案：**
如果不需要一个完全排序的数组，或者只需要获取前 K 个排序后的元素，可以考虑以下替代方案来避免 O(N log N) 的排序开销：

1.  **避免 `toArray()` 如果只需要 Top K 元素：** 如果只需要获取堆中分数最高（或最低）的 K 个元素，可以重复调用 `pop()` 方法 K 次。由于最小堆每次弹出的是当前堆中的最小元素，因此连续弹出 K 次会得到 K 个最小元素，它们本身是按升序排列的。如果需要降序，可以简单地对这 K 个元素进行一次 `reverse()` 操作，其时间复杂度为 O(K)。这比对整个堆进行排序（O(N log N)）要高效得多，尤其是在 K 远小于 N 的情况下。

2.  **文档说明性能影响：** 在 `toArray()` 方法的 JSDoc 注释中明确说明其性能开销，并建议用户在性能敏感的场景下考虑使用其他方法（例如连续 `pop()`）。

3.  **提供一个返回未排序数组的方法：** 如果用户只需要获取堆中所有元素的列表，而不需要它们是排序的，可以提供一个 `toUnsortedArray()` 方法，它只返回 `[...this.heap]` 而不进行排序。

对于 `toArray()` 方法本身，其返回一个“排序后的数组”的语义决定了排序是其核心操作。因此，这里的优化主要在于提醒调用方注意其性能特性，并根据实际需求选择更高效的替代方案。